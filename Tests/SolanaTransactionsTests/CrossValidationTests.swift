import Foundation
import Testing
import SwiftBorsh

@testable import SolanaTransactions

/// Cross-validation tests using known transaction vectors
/// These tests use transaction bytes that would be generated by web3.js
/// to ensure compatibility with the standard Solana transaction format

// MARK: - Known Transaction Vectors

@Test func knownTransferTransaction() throws {
    // This is a real Solana transfer transaction encoded by web3.js
    // Transfer of 10,000,000 lamports from one account to another
    let base64Transaction =
        "AVY2OiCW17TmRtYkLf5hXChKiLI426BCzVvm3HVWbfc9jB/bbeXBdr44qqHonxaXU72IujL8UxMHINFxdbiZrAaAAQABA406Qf3ITsphmePq8Dhvj5KuE1qYX1hOPOf02gP1OnSxqj7yZT8FPL8rBX8RYTg1teUdYh7ObB0gKMsyfCMWtzYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL7kT4hrkBAe9WQXo7ozykFkocGm47yXhDkJOG244K5sAQICAAEMAgAAAICWmAAAAAAAAA=="

    let transaction = try Transaction(bytes: Data(base64Encoded: base64Transaction)!)

    // Verify message type
    switch transaction.message {
    case .v0(let msg):
        // Verify basic structure
        #expect(msg.signatureCount == 1)
        #expect(msg.readOnlyAccounts == 0)
        #expect(msg.readOnlyNonSigners == 1)

        // Verify accounts
        #expect(msg.accounts.count == 3)
        #expect(msg.accounts[0] == "AWJ1WoX9w7hXQeMnaJTe92GHnBtCQZ5MWquCGDiZCqAG")
        #expect(msg.accounts[1] == "CTZynpom8nofKjsdcYGTk3eWLpUeZQUvXd68dFphWKWu")
        #expect(msg.accounts[2] == "11111111111111111111111111111111")

        // Verify blockhash
        #expect(msg.blockhash == "DrAP91wtHVsYp64PYyhGLJXtbYMQt7Sss47YdKUV1Xzj")

        // Verify instruction
        #expect(msg.instructions.count == 1)
        #expect(msg.instructions[0].programIdIndex == 2)
        #expect(msg.instructions[0].accounts == [0, 1])

        // Verify instruction data (transfer with 10,000,000 lamports)
        let expectedData: [UInt8] = [2, 0, 0, 0, 128, 150, 152, 0, 0, 0, 0, 0]
        #expect(msg.instructions[0].data == expectedData)

        // Verify no address table lookups
        #expect(msg.addressTableLookups.isEmpty)

    case .legacyMessage:
        Issue.record("Expected V0 message format")
    }

    // Verify signature
    #expect(transaction.signatures.count == 1)

    // Verify round-trip encoding
    let reencoded = try transaction.encode()
    let redecoded = try Transaction(bytes: reencoded)
    #expect(redecoded == transaction)
}

@Test func knownLegacyTransaction() throws {
    // A simple legacy format transaction (no version prefix)
    // This simulates a transaction created by older versions of web3.js
    let message = LegacyMessage(
        signatureCount: 1,
        readOnlyAccounts: 0,
        readOnlyNonSigners: 1,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            "FEECf2pRMbC5y3YJvPTkhtXZh6U3PJEBFRfvJBGHN4zh",
            "11111111111111111111111111111111",
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            CompiledInstruction(
                programIdIndex: 2,
                accounts: [0, 1],
                data: [2, 0, 0, 0, 0, 202, 154, 59, 0, 0, 0, 0]  // 1,000,000,000 lamports (1 SOL)
            )
        ]
    )

    let transaction = Transaction(signatures: [], message: .legacyMessage(message))

    // Encode and verify it decodes correctly
    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)

    // Verify it's recognized as legacy format
    switch decoded.message {
    case .legacyMessage:
        break  // Expected
    case .v0:
        Issue.record("Should be legacy message")
    }
}

@Test func knownTokenTransferTransaction() throws {
    // Token transfer transaction matching web3.js SPL Token transfer
    let message = LegacyMessage(
        signatureCount: 1,
        readOnlyAccounts: 0,
        readOnlyNonSigners: 2,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",  // owner/signer
            "2wmVCSfPxGPjrnMMn7rchp4uaeoTqN39mXFC2zhPdri9",  // source token account
            "CKSVCCfJ9SZkUr3Y9kTLNzUmZPgUZMbNwNJ2kXRubNjS",  // destination token account
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",   // token program
            "11111111111111111111111111111111",              // system program
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            CompiledInstruction(
                programIdIndex: 3,
                accounts: [1, 2, 0],
                data: [3, 64, 66, 15, 0, 0, 0, 0, 0]  // Transfer 1,000,000 tokens
            )
        ]
    )

    let transaction = Transaction(signatures: [], message: .legacyMessage(message))

    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)

    switch decoded.message {
    case .legacyMessage(let msg):
        #expect(msg.instructions[0].data[0] == 3)  // Transfer instruction
        #expect(msg.instructions[0].programIdIndex == 3)
    case .v0:
        Issue.record("Expected legacy message")
    }
}

@Test func knownMemoTransaction() throws {
    // Transaction with memo instruction
    let memoText = "Hello Solana!"
    var memoData = [UInt8]()
    memoData.append(contentsOf: withUnsafeBytes(of: UInt32(memoText.utf8.count).littleEndian) { Array($0) })
    memoData.append(contentsOf: memoText.utf8)

    let message = LegacyMessage(
        signatureCount: 1,
        readOnlyAccounts: 0,
        readOnlyNonSigners: 1,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr",
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            CompiledInstruction(
                programIdIndex: 1,
                accounts: [0],
                data: memoData
            )
        ]
    )

    let transaction = Transaction(signatures: [], message: .legacyMessage(message))

    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)
}

@Test func knownV0TransactionWithLookupTables() throws {
    // V0 transaction using address lookup tables
    let lookup = AddressTableLookup(
        account: "2wmVCSfPxGPjrnMMn7rchp4uaeoTqN39mXFC2zhPdri9",
        writableIndexes: [0, 1],
        readOnlyIndexes: [2, 3, 4]
    )

    let message = V0Message(
        signatureCount: 1,
        readOnlyAccounts: 0,
        readOnlyNonSigners: 1,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            "11111111111111111111111111111111",
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            CompiledInstruction(
                programIdIndex: 1,
                accounts: [0, 2, 3],  // References to lookup table
                data: [2, 0, 0, 0, 0, 202, 154, 59, 0, 0, 0, 0]
            )
        ],
        addressTableLookups: [lookup]
    )

    let transaction = Transaction(signatures: [], message: .v0(message))

    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)

    // Verify version byte
    #expect(encoded[0] == 0)  // no signatures
    #expect(encoded[1] == 0x80)  // v0 version byte

    switch decoded.message {
    case .v0(let msg):
        #expect(msg.addressTableLookups.count == 1)
        #expect(msg.addressTableLookups[0].writableIndexes == [0, 1])
        #expect(msg.addressTableLookups[0].readOnlyIndexes == [2, 3, 4])
    case .legacyMessage:
        Issue.record("Expected V0 message")
    }
}

// MARK: - Instruction Data Format Validation

@Test func systemTransferInstructionFormat() throws {
    // Validate system transfer instruction matches web3.js format
    // Format: [u32 instruction_index (0 for transfer), u64 lamports]
    let lamports: UInt64 = 1_000_000

    var expectedData = [UInt8]()
    // Instruction index (0 for transfer) as i32
    expectedData.append(contentsOf: [0, 0, 0, 0])
    // Lamports as i64 little-endian
    expectedData.append(contentsOf: [64, 66, 15, 0, 0, 0, 0, 0])

    let instruction = SystemProgram.transfer(
        from: "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
        to: "FEECf2pRMbC5y3YJvPTkhtXZh6U3PJEBFRfvJBGHN4zh",
        lamports: Int64(lamports)
    )

    var buffer = BorshByteBuffer()
    try instruction.data.borshEncode(to: &buffer)
    let encoded = buffer.readBytes(length: buffer.readableBytes) ?? []

    #expect(encoded == expectedData)
}

@Test func tokenTransferInstructionFormat() throws {
    // Validate token transfer instruction matches web3.js SPL Token format
    // Format: [u8 instruction_index (3 for transfer), u64 amount]
    let amount: UInt64 = 1_000_000

    var expectedData = [UInt8]()
    expectedData.append(3)  // Transfer instruction
    expectedData.append(contentsOf: [64, 66, 15, 0, 0, 0, 0, 0])  // amount as i64

    let instruction = TokenProgram.transfer(
        from: "2wmVCSfPxGPjrnMMn7rchp4uaeoTqN39mXFC2zhPdri9",
        to: "CKSVCCfJ9SZkUr3Y9kTLNzUmZPgUZMbNwNJ2kXRubNjS",
        amount: Int64(amount),
        owner: "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g"
    )

    var buffer = BorshByteBuffer()
    try instruction.data.borshEncode(to: &buffer)
    let encoded = buffer.readBytes(length: buffer.readableBytes) ?? []

    #expect(encoded == expectedData)
}

@Test func tokenTransferCheckedInstructionFormat() throws {
    // Format: [u8 instruction_index (12), u64 amount, u8 decimals]
    let amount: UInt64 = 1_000_000
    let decimals: UInt8 = 6

    var expectedData = [UInt8]()
    expectedData.append(12)  // TransferChecked instruction
    expectedData.append(contentsOf: [64, 66, 15, 0, 0, 0, 0, 0])  // amount
    expectedData.append(decimals)

    let instruction = TokenProgram.transferChecked(
        from: "2wmVCSfPxGPjrnMMn7rchp4uaeoTqN39mXFC2zhPdri9",
        to: "CKSVCCfJ9SZkUr3Y9kTLNzUmZPgUZMbNwNJ2kXRubNjS",
        amount: Int64(amount),
        decimals: decimals,
        owner: "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
        mint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
    )

    var buffer = BorshByteBuffer()
    try instruction.data.borshEncode(to: &buffer)
    let encoded = buffer.readBytes(length: buffer.readableBytes) ?? []

    #expect(encoded == expectedData)
}

// MARK: - Complex Real-World Scenarios

@Test func swapTransaction() throws {
    // Simulates a token swap transaction (simplified)
    // In reality this would involve Jupiter or Raydium, but we'll use basic token transfers
    let message = LegacyMessage(
        signatureCount: 1,
        readOnlyAccounts: 0,
        readOnlyNonSigners: 3,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",  // owner
            "2wmVCSfPxGPjrnMMn7rchp4uaeoTqN39mXFC2zhPdri9",  // source (valid pubkey)
            "CKSVCCfJ9SZkUr3Y9kTLNzUmZPgUZMbNwNJ2kXRubNjS",  // destination (valid pubkey)
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",   // token program
            "11111111111111111111111111111111",              // system program
            "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr",   // memo program
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            // Token transfer
            CompiledInstruction(
                programIdIndex: 3,
                accounts: [1, 2, 0],
                data: [3, 0, 202, 154, 59, 0, 0, 0, 0]
            ),
            // Memo
            CompiledInstruction(
                programIdIndex: 5,
                accounts: [0],
                data: [4, 0, 0, 0, 83, 119, 97, 112]  // "Swap"
            ),
        ]
    )

    let transaction = Transaction(signatures: [], message: .legacyMessage(message))

    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)

    switch decoded.message {
    case .legacyMessage(let msg):
        #expect(msg.instructions.count == 2)
    case .v0:
        Issue.record("Expected legacy message")
    }
}

@Test func nftMintTransaction() throws {
    // Simulates an NFT minting transaction
    let message = LegacyMessage(
        signatureCount: 2,  // Mint account and payer both sign
        readOnlyAccounts: 0,
        readOnlyNonSigners: 3,
        accounts: [
            "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",  // payer (signer)
            "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",  // mint (signer) - valid pubkey
            "5n7VBS8hXLkjJzD1JRJndFV92jDpQ1PwZ4dvGQNqvCKp",  // token account - valid pubkey
            "11111111111111111111111111111111",              // system program
            "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",   // token program
            "SysvarRent111111111111111111111111111111111",   // rent sysvar
        ],
        blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4",
        instructions: [
            // Create account for mint
            CompiledInstruction(
                programIdIndex: 3,
                accounts: [0, 1],
                data: [2, 0, 0, 0, 64, 66, 15, 0, 0, 0, 0, 0, 82, 0, 0, 0, 0, 0, 0, 0]
                    + Array("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA".utf8.prefix(32))
            ),
            // Initialize mint (0 decimals for NFT)
            CompiledInstruction(
                programIdIndex: 4,
                accounts: [1, 5],
                data: [0, 0] + Array("9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g".utf8.prefix(32))
            ),
        ]
    )

    let transaction = Transaction(signatures: [], message: .legacyMessage(message))

    let encoded = try transaction.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == transaction)

    switch decoded.message {
    case .legacyMessage(let msg):
        #expect(msg.signatureCount == 2)
        #expect(msg.instructions.count == 2)
    case .v0:
        Issue.record("Expected legacy message")
    }
}

// MARK: - Compatibility Tests

@Test func roundTripWithWeb3jsFormat() throws {
    // Create a transaction in the exact format web3.js would create
    let tx = try Transaction(blockhash: "4NCYB3kRT8sCNodPNuCZo8VUh4xqpBQxsxed2wd9xaD4") {
        SystemProgram.transfer(
            from: "9B5XszUGdMaxCZ7uSQhPzdks5ZQSmWxrmzCSvtJ6Ns6g",
            to: "FEECf2pRMbC5y3YJvPTkhtXZh6U3PJEBFRfvJBGHN4zh",
            lamports: 1_000_000_000
        )
    }

    // Encode, decode, and verify
    let encoded = try tx.encode()
    let decoded = try Transaction(bytes: encoded)

    #expect(decoded == tx)

    // Verify instruction data matches expected format
    switch decoded.message {
    case .legacyMessage(let msg):
        let instruction = msg.instructions[0]
        #expect(instruction.data.count == 12)
        #expect(instruction.data[0...3] == [0, 0, 0, 0])  // index 0
        #expect(instruction.data[4...11] == [0, 202, 154, 59, 0, 0, 0, 0])  // 1 SOL
    case .v0:
        Issue.record("Expected legacy message")
    }
}
